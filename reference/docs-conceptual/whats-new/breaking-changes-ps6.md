---
ms.date: 05/17/2018
keywords: prostředí PowerShell, core
title: Rozbíjející změny v Powershellu 6.0
ms.openlocfilehash: d477a9b27e8d5df6653ee40f8b606879b60a80c7
ms.sourcegitcommit: 548547b2d5fc73e726bb9fec6175d452a351d975
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/20/2018
ms.locfileid: "53655442"
---
# <a name="breaking-changes-for-powershell-60"></a><span data-ttu-id="6ca53-103">Rozbíjející změny v Powershellu 6.0</span><span class="sxs-lookup"><span data-stu-id="6ca53-103">Breaking Changes for PowerShell 6.0</span></span>

## <a name="features-no-longer-available-in-powershell-core"></a><span data-ttu-id="6ca53-104">Funkce, které již nejsou k dispozici v Powershellu Core</span><span class="sxs-lookup"><span data-stu-id="6ca53-104">Features no longer available in PowerShell Core</span></span>

### <a name="powershell-workflow"></a><span data-ttu-id="6ca53-105">Pracovní postup prostředí PowerShell</span><span class="sxs-lookup"><span data-stu-id="6ca53-105">PowerShell Workflow</span></span>

<span data-ttu-id="6ca53-106">[Pracovní postup Powershellu] [ workflow] je funkce ve Windows Powershellu, který vytváří nad [Windows Workflow Foundation (WF)] [ workflow-foundation] , která umožňuje vytváření Robustní sady runbook pro dlouho běžící nebo paralelizované úloh.</span><span class="sxs-lookup"><span data-stu-id="6ca53-106">[PowerShell Workflow][workflow] is a feature in Windows PowerShell that builds on top of [Windows Workflow Foundation (WF)][workflow-foundation] that enables the creation of robust runbooks for long-running or parallelized tasks.</span></span>

<span data-ttu-id="6ca53-107">Z důvodu chybějící podpora jazyků Windows Workflow Foundation v .NET Core jsme nebude nadále podporovat pracovního postupu Powershellu v prostředí PowerShell Core.</span><span class="sxs-lookup"><span data-stu-id="6ca53-107">Due to the lack of support for Windows Workflow Foundation in .NET Core, we will not continue to support PowerShell Workflow in PowerShell Core.</span></span>

<span data-ttu-id="6ca53-108">V budoucnu rádi bychom Povolit nativní paralelismu/souběžnosti v jazyce Powershellu bez pracovního postupu Powershellu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-108">In the future, we would like to enable native parallelism/concurrency in the PowerShell language without the need for PowerShell Workflow.</span></span>

[workflow]: https://docs.microsoft.com/powershell/scripting/core-powershell/workflows-guide
[workflow-foundation]: https://docs.microsoft.com/dotnet/framework/windows-workflow-foundation/

### <a name="custom-snap-ins"></a><span data-ttu-id="6ca53-109">Vlastní moduly snap in</span><span class="sxs-lookup"><span data-stu-id="6ca53-109">Custom snap-ins</span></span>

<span data-ttu-id="6ca53-110">[Moduly snap in prostředí PowerShell] [ snapin] jsou předchůdce do modulů Powershellu, které nemají jeho využití v komunitě prostředí PowerShell.</span><span class="sxs-lookup"><span data-stu-id="6ca53-110">[PowerShell snap-ins][snapin] are a predecessor to PowerShell modules that do not have widespread adoption in the PowerShell community.</span></span>

<span data-ttu-id="6ca53-111">Z důvodu složitosti podpora moduly snap in a jejich nedostatečné využití v komunitě už nadále nepodporujeme vlastní moduly snap in v prostředí PowerShell Core.</span><span class="sxs-lookup"><span data-stu-id="6ca53-111">Due to the complexity of supporting snap-ins and their lack of usage in the community, we no longer support custom snap-ins in PowerShell Core.</span></span>

<span data-ttu-id="6ca53-112">V současné době tím je prolomen `ActiveDirectory` a `DnsClient` moduly ve Windows a Windows serveru.</span><span class="sxs-lookup"><span data-stu-id="6ca53-112">Today, this breaks the `ActiveDirectory` and `DnsClient` modules in Windows and Windows Server.</span></span>

[snapin]: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pssnapins

### <a name="wmi-v1-cmdlets"></a><span data-ttu-id="6ca53-113">Rutiny WMI v1</span><span class="sxs-lookup"><span data-stu-id="6ca53-113">WMI v1 cmdlets</span></span>

<span data-ttu-id="6ca53-114">Z důvodu složitosti podporu dvou sad založených na rozhraní WMI modulů jsme odebrali rutiny WMI v1 z Powershellu Core:</span><span class="sxs-lookup"><span data-stu-id="6ca53-114">Due to the complexity of supporting two sets of WMI-based modules, we removed the WMI v1 cmdlets from PowerShell Core:</span></span>

- `Get-WmiObject`
- `Invoke-WmiMethod`
- `Register-WmiEvent`
- `Set-WmiInstance`

<span data-ttu-id="6ca53-115">Místo toho doporučujeme, aby vám použití rutin modelu CIM (označuje se také jako WMI v2), které poskytují stejné funkce s přepracovaný syntaxi a nové funkce:</span><span class="sxs-lookup"><span data-stu-id="6ca53-115">Instead, we recommend that you the use the CIM (aka WMI v2) cmdlets which provide the same functionality with new functionality and a redesigned syntax:</span></span>

- `Get-CimAssociatedInstance`
- `Get-CimClass`
- `Get-CimInstance`
- `Get-CimSession`
- `Invoke-CimMethod`
- `New-CimInstance`
- `New-CimSession`
- `New-CimSessionOption`
- `Register-CimIndicationEvent`
- `Remove-CimInstance`
- `Remove-CimSession`
- `Set-CimInstance`

### <a name="microsoftpowershelllocalaccounts"></a><span data-ttu-id="6ca53-116">Microsoft.PowerShell.LocalAccounts</span><span class="sxs-lookup"><span data-stu-id="6ca53-116">Microsoft.PowerShell.LocalAccounts</span></span>

<span data-ttu-id="6ca53-117">Kvůli použití nepodporované rozhraní API `Microsoft.PowerShell.LocalAccounts` je odebraná ze PowerShell Core, dokud nebude nalezen lepší řešení.</span><span class="sxs-lookup"><span data-stu-id="6ca53-117">Due to the use of unsupported APIs, `Microsoft.PowerShell.LocalAccounts` has been removed from PowerShell Core until a better solution is found.</span></span>

### <a name="-counter-cmdlets"></a><span data-ttu-id="6ca53-118">Rutiny pro `*-Counter`</span><span class="sxs-lookup"><span data-stu-id="6ca53-118">`*-Counter` cmdlets</span></span>

<span data-ttu-id="6ca53-119">Kvůli použití nepodporované rozhraní API `*-Counter` je odebraná ze PowerShell Core, dokud nebude nalezen lepší řešení.</span><span class="sxs-lookup"><span data-stu-id="6ca53-119">Due to the use of unsupported APIs, the `*-Counter` has been removed from PowerShell Core until a better solution is found.</span></span>

## <a name="enginelanguage-changes"></a><span data-ttu-id="6ca53-120">Modul/jazykové změny</span><span class="sxs-lookup"><span data-stu-id="6ca53-120">Engine/language changes</span></span>

### <a name="rename-powershellexe-to-pwshexe-5101httpsgithubcompowershellpowershellissues5101"></a><span data-ttu-id="6ca53-121">Přejmenovat `powershell.exe` k `pwsh.exe` [#5101](https://github.com/PowerShell/PowerShell/issues/5101)</span><span class="sxs-lookup"><span data-stu-id="6ca53-121">Rename `powershell.exe` to `pwsh.exe` [#5101](https://github.com/PowerShell/PowerShell/issues/5101)</span></span>

<span data-ttu-id="6ca53-122">Pokud chcete uživatelům udělit deterministické způsob, jak volat Powershellu Core ve Windows (na rozdíl od Windows Powershellu), prostředí PowerShell Core binární soubor byl změněn na `pwsh.exe` na Windows a `pwsh` na platformách než Windows.</span><span class="sxs-lookup"><span data-stu-id="6ca53-122">In order to give users a deterministic way to call PowerShell Core on Windows (as opposed to Windows PowerShell), the PowerShell Core binary was changed to `pwsh.exe` on Windows and `pwsh` on non-Windows platforms.</span></span>

<span data-ttu-id="6ca53-123">Zkrácený název je také konzistentní s pojmenování prostředí na platformách než Windows.</span><span class="sxs-lookup"><span data-stu-id="6ca53-123">The shortened name is also consistent with naming of shells on non-Windows platforms.</span></span>

### <a name="dont-insert-line-breaks-to-output-except-for-tables-5193httpsgithubcompowershellpowershellissues5193"></a><span data-ttu-id="6ca53-124">Nevkládejte konce řádků výstupu (s výjimkou tabulky) [#5193](https://github.com/PowerShell/PowerShell/issues/5193)</span><span class="sxs-lookup"><span data-stu-id="6ca53-124">Don't insert line breaks to output (except for tables) [#5193](https://github.com/PowerShell/PowerShell/issues/5193)</span></span>

<span data-ttu-id="6ca53-125">Dříve výstup byl zarovnané šířce konzole a zalomení řádků byly přidány na koncová šířka konzoly, což znamená, že výstup nepovedlo získat přeformátovali podle očekávání, pokud se změnila terminálu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-125">Previously, output was aligned to the width of the console and line breaks were added at the end width of the console, meaning the output didn't get reformatted as expected if the terminal was resized.</span></span> <span data-ttu-id="6ca53-126">Tato změna se neaplikovala k tabulkám, jsou také k zachování konzistence sloupce zarovnané konce řádků.</span><span class="sxs-lookup"><span data-stu-id="6ca53-126">This change was not applied to tables, as the line breaks are necessary to keep the columns aligned.</span></span>

### <a name="skip-null-element-check-for-collections-with-a-value-type-element-type-5432httpsgithubcompowershellpowershellissues5432"></a><span data-ttu-id="6ca53-127">Přeskočení kontroly element s hodnotou null pro kolekce s typem elementu typu hodnoty [#5432](https://github.com/PowerShell/PowerShell/issues/5432)</span><span class="sxs-lookup"><span data-stu-id="6ca53-127">Skip null-element check for collections with a value-type element type [#5432](https://github.com/PowerShell/PowerShell/issues/5432)</span></span>

<span data-ttu-id="6ca53-128">Pro `Mandatory` parametr a `ValidateNotNull` a `ValidateNotNullOrEmpty` atributy, Přeskočit kontrolu element s hodnotou null, pokud typ elementu kolekce je typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="6ca53-128">For the `Mandatory` parameter and `ValidateNotNull` and `ValidateNotNullOrEmpty` attributes, skip the null-element check if the collection's element type is value type.</span></span>

### <a name="change-outputencoding-to-use-utf-8-nobom-encoding-rather-than-ascii-5369httpsgithubcompowershellpowershellissues5369"></a><span data-ttu-id="6ca53-129">Změna `$OutputEncoding` používat `UTF-8 NoBOM` kódování místo ASCII [#5369](https://github.com/PowerShell/PowerShell/issues/5369)</span><span class="sxs-lookup"><span data-stu-id="6ca53-129">Change `$OutputEncoding` to use `UTF-8 NoBOM` encoding rather than ASCII [#5369](https://github.com/PowerShell/PowerShell/issues/5369)</span></span>

<span data-ttu-id="6ca53-130">Výsledkem předchozího kódování, ASCII (7-bit), budou nesprávné změnu ve výstupu v některých případech.</span><span class="sxs-lookup"><span data-stu-id="6ca53-130">The previous encoding, ASCII (7-bit), would result in incorrect alteration of the output in some cases.</span></span> <span data-ttu-id="6ca53-131">Tato změna je, aby `UTF-8 NoBOM` výchozí, což zachová výstup ve formátu Unicode s kódováním nepodporuje většiny nástrojů a operačních systémů.</span><span class="sxs-lookup"><span data-stu-id="6ca53-131">This change is to make `UTF-8 NoBOM` default, which preserves Unicode output with an encoding supported by most tools and operating systems.</span></span>

### <a name="remove-allscope-from-most-default-aliases-5268httpsgithubcompowershellpowershellissues5268"></a><span data-ttu-id="6ca53-132">Odebrat `AllScope` z většiny výchozí aliasy [#5268](https://github.com/PowerShell/PowerShell/issues/5268)</span><span class="sxs-lookup"><span data-stu-id="6ca53-132">Remove `AllScope` from most default aliases [#5268](https://github.com/PowerShell/PowerShell/issues/5268)</span></span>

<span data-ttu-id="6ca53-133">Ke zrychlení vytváření oboru `AllScope` byl odebrán z většiny výchozí aliasy.</span><span class="sxs-lookup"><span data-stu-id="6ca53-133">To speed up scope creation, `AllScope` was removed from most default aliases.</span></span> <span data-ttu-id="6ca53-134">`AllScope` byla ponechána pro několik často používané aliasy místo, kde bylo rychlejší vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="6ca53-134">`AllScope` was left for a few frequently used aliases where the lookup was faster.</span></span>

### <a name="-verbose-and--debug-no-longer-overrides-erroractionpreference-5113httpsgithubcompowershellpowershellissues5113"></a><span data-ttu-id="6ca53-135">`-Verbose` a `-Debug` už přepíše `$ErrorActionPreference` [#5113](https://github.com/PowerShell/PowerShell/issues/5113)</span><span class="sxs-lookup"><span data-stu-id="6ca53-135">`-Verbose` and `-Debug` no longer overrides `$ErrorActionPreference` [#5113](https://github.com/PowerShell/PowerShell/issues/5113)</span></span>

<span data-ttu-id="6ca53-136">Dříve Pokud `-Verbose` nebo `-Debug` byly zadány overrode chování `$ErrorActionPreference`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-136">Previously, if `-Verbose` or `-Debug` were specified, it overrode the behavior of `$ErrorActionPreference`.</span></span> <span data-ttu-id="6ca53-137">Díky této změně `-Verbose` a `-Debug` už nebude mít vliv na chování `$ErrorActionPreference`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-137">With this change, `-Verbose` and `-Debug` no longer affect the behavior of `$ErrorActionPreference`.</span></span>

## <a name="cmdlet-changes"></a><span data-ttu-id="6ca53-138">Změny rutin</span><span class="sxs-lookup"><span data-stu-id="6ca53-138">Cmdlet changes</span></span>

### <a name="invoke-restmethod-doesnt-return-useful-info-when-no-data-is-returned-5320httpsgithubcompowershellpowershellissues5320"></a><span data-ttu-id="6ca53-139">Vyvolání RestMethod nevrací užitečných informací, když nebudou vrácena žádná data.</span><span class="sxs-lookup"><span data-stu-id="6ca53-139">Invoke-RestMethod doesn't return useful info when no data is returned.</span></span> [<span data-ttu-id="6ca53-140">#5320</span><span class="sxs-lookup"><span data-stu-id="6ca53-140">#5320</span></span>](https://github.com/PowerShell/PowerShell/issues/5320)

<span data-ttu-id="6ca53-141">Pokud rozhraní API vrátí jenom `null`, Invoke-RestMethod to byla serializaci jako řetězec `"null"` místo `$null`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-141">When an API returns just `null`, Invoke-RestMethod was serializing this as the string `"null"` instead of `$null`.</span></span> <span data-ttu-id="6ca53-142">Tato změna řeší logika `Invoke-RestMethod` správně serializovat platnou hodnotu typu single JSON `null` literálu jako `$null`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-142">This change fixes the logic in `Invoke-RestMethod` to properly serialize a valid single value JSON `null` literal as `$null`.</span></span>

### <a name="remove--computername-from--computer-cmdlets-5277httpsgithubcompowershellpowershellissues5277"></a><span data-ttu-id="6ca53-143">Odebrat `-ComputerName` z `*-Computer` rutiny [#5277](https://github.com/PowerShell/PowerShell/issues/5277)</span><span class="sxs-lookup"><span data-stu-id="6ca53-143">Remove `-ComputerName` from `*-Computer` cmdlets [#5277](https://github.com/PowerShell/PowerShell/issues/5277)</span></span>

<span data-ttu-id="6ca53-144">Kvůli problémům s vzdálené komunikace RPC v CoreFX (zejména na platformách než Windows) a zajištění konzistentní vzdálenou komunikaci prostředí v Powershellu `-ComputerName` parametr byl odebrán z `\*-Computer` rutiny.</span><span class="sxs-lookup"><span data-stu-id="6ca53-144">Due to issues with RPC remoting in CoreFX (particularly on non-Windows platforms) and ensuring a consistent remoting experience in PowerShell, the `-ComputerName` parameter was removed from the `\*-Computer` cmdlets.</span></span> <span data-ttu-id="6ca53-145">Použití `Invoke-Command` místo jako způsob, jak vzdálené spouštění rutin.</span><span class="sxs-lookup"><span data-stu-id="6ca53-145">Use `Invoke-Command` instead as the way to execute cmdlets remotely.</span></span>

### <a name="remove--computername-from--service-cmdlets-5090httpsgithubcompowershellpowershellissues5094"></a><span data-ttu-id="6ca53-146">Odebrat `-ComputerName` z `*-Service` rutiny [#5090](https://github.com/PowerShell/PowerShell/issues/5094)</span><span class="sxs-lookup"><span data-stu-id="6ca53-146">Remove `-ComputerName` from `*-Service` cmdlets [#5090](https://github.com/PowerShell/PowerShell/issues/5094)</span></span>

<span data-ttu-id="6ca53-147">Aby bylo možné podporovat konzistentním použitím PSRP, `-ComputerName` parametr byl odebrán z `*-Service` rutiny.</span><span class="sxs-lookup"><span data-stu-id="6ca53-147">In order to encourage the consistent use of PSRP, the `-ComputerName` parameter was removed from `*-Service` cmdlets.</span></span>

### <a name="fix-get-item--literalpath-ab-if-ab-doesnt-actually-exist-to-return-error-5197httpsgithubcompowershellpowershellissues5197"></a><span data-ttu-id="6ca53-148">Oprava `Get-Item -LiteralPath a*b` Pokud `a*b` neexistuje ve skutečnosti k vrácení chyby [#5197](https://github.com/PowerShell/PowerShell/issues/5197)</span><span class="sxs-lookup"><span data-stu-id="6ca53-148">Fix `Get-Item -LiteralPath a*b` if `a*b` doesn't actually exist to return error [#5197](https://github.com/PowerShell/PowerShell/issues/5197)</span></span>

<span data-ttu-id="6ca53-149">Dříve `-LiteralPath` daný zástupný znak by ji považovat za stejné `-Path` a pokud zástupný znak nenajde žádné soubory, bude tiše ukončíte.</span><span class="sxs-lookup"><span data-stu-id="6ca53-149">Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard found no files, it would silently exit.</span></span> <span data-ttu-id="6ca53-150">Správné chování, která by měla být `-LiteralPath` je literál, takže pokud soubor neexistuje, by mělo chyby.</span><span class="sxs-lookup"><span data-stu-id="6ca53-150">Correct behavior should be that `-LiteralPath` is literal so if the file doesn't exist, it should error.</span></span> <span data-ttu-id="6ca53-151">Změna se zachází zástupných znaků použít s `-Literal` jako literál.</span><span class="sxs-lookup"><span data-stu-id="6ca53-151">Change is to treat wildcards used with `-Literal` as literal.</span></span>

### <a name="import-csv-should-apply-pstypenames-upon-import-when-type-information-is-present-in-the-csv-5134httpsgithubcompowershellpowershellissues5134"></a><span data-ttu-id="6ca53-152">`Import-Csv` by se měly používat `PSTypeNames` po import po informace o typu se nachází ve sdíleném svazku clusteru [#5134](https://github.com/PowerShell/PowerShell/issues/5134)</span><span class="sxs-lookup"><span data-stu-id="6ca53-152">`Import-Csv` should apply `PSTypeNames` upon import when type information is present in the CSV [#5134](https://github.com/PowerShell/PowerShell/issues/5134)</span></span>

<span data-ttu-id="6ca53-153">Dříve, exportovat objekty pomocí `Export-CSV` s `TypeInformation` importovat s `ConvertFrom-Csv` nebyly zachování informací o typu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-153">Previously, objects exported using `Export-CSV` with `TypeInformation` imported with `ConvertFrom-Csv` were not retaining the type information.</span></span> <span data-ttu-id="6ca53-154">Přidá informace o typu pro tuto změnu `PSTypeNames` člen, pokud je k dispozici ze souboru CSV.</span><span class="sxs-lookup"><span data-stu-id="6ca53-154">This change adds the type information to `PSTypeNames` member if available from the CSV file.</span></span>

### <a name="-notypeinformation-should-be-default-on-export-csv-5131httpsgithubcompowershellpowershellissues5131"></a><span data-ttu-id="6ca53-155">`-NoTypeInformation` by měla být výchozí na `Export-Csv` [#5131](https://github.com/PowerShell/PowerShell/issues/5131)</span><span class="sxs-lookup"><span data-stu-id="6ca53-155">`-NoTypeInformation` should be default on `Export-Csv` [#5131](https://github.com/PowerShell/PowerShell/issues/5131)</span></span>

<span data-ttu-id="6ca53-156">Tato změna byla provedena na zpětnou vazbu zákazníků na výchozí chování `Export-CSV` zahrnout informace o typu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-156">This change was made to address customer feedback on the default behavior of `Export-CSV` to include type information.</span></span>

<span data-ttu-id="6ca53-157">Dříve by výstup rutiny komentář jako první řádek, který obsahuje název typu objektu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-157">Previously, the cmdlet would output a comment as the first line containing the type name of the object.</span></span> <span data-ttu-id="6ca53-158">Změna je potlačit to ve výchozím nastavení, jak ho většina nástrojů nerozumí.</span><span class="sxs-lookup"><span data-stu-id="6ca53-158">The change is to suppress this by default as it's not understood by most tools.</span></span> <span data-ttu-id="6ca53-159">Použití `-IncludeTypeInformation` zachovat předchozí chování.</span><span class="sxs-lookup"><span data-stu-id="6ca53-159">Use `-IncludeTypeInformation` to retain the previous behavior.</span></span>

### <a name="web-cmdlets-should-warn-when--credential-is-sent-over-unencrypted-connections-5112httpsgithubcompowershellpowershellissues5112"></a><span data-ttu-id="6ca53-160">Rutiny web by měl zobrazit upozornění při `-Credential` je odeslán přes nezašifrované připojení [#5112](https://github.com/PowerShell/PowerShell/issues/5112)</span><span class="sxs-lookup"><span data-stu-id="6ca53-160">Web Cmdlets should warn when `-Credential` is sent over unencrypted connections [#5112](https://github.com/PowerShell/PowerShell/issues/5112)</span></span>

<span data-ttu-id="6ca53-161">Při použití protokolu HTTP, obsah, včetně hesel odeslány jako nešifrovaný text.</span><span class="sxs-lookup"><span data-stu-id="6ca53-161">When using HTTP, content including passwords are sent as clear-text.</span></span> <span data-ttu-id="6ca53-162">Tato změna je to nepovolují ve výchozím nastavení a vrátí chybu, pokud se přihlašovací údaje jsou předávány nezabezpečeným způsobem.</span><span class="sxs-lookup"><span data-stu-id="6ca53-162">This change is to not allow this by default and return an error if credentials are being passed in an insecure manner.</span></span> <span data-ttu-id="6ca53-163">Uživatelé mohou obejít tím pomocí `-AllowUnencryptedAuthentication` přepnout.</span><span class="sxs-lookup"><span data-stu-id="6ca53-163">Users can bypass this by using the `-AllowUnencryptedAuthentication` switch.</span></span>

## <a name="api-changes"></a><span data-ttu-id="6ca53-164">Změny rozhraní API</span><span class="sxs-lookup"><span data-stu-id="6ca53-164">API changes</span></span>

### <a name="remove-addtypecommandbase-class-5407httpsgithubcompowershellpowershellissues5407"></a><span data-ttu-id="6ca53-165">Odebrat `AddTypeCommandBase` třídy [#5407](https://github.com/PowerShell/PowerShell/issues/5407)</span><span class="sxs-lookup"><span data-stu-id="6ca53-165">Remove `AddTypeCommandBase` class [#5407](https://github.com/PowerShell/PowerShell/issues/5407)</span></span>

<span data-ttu-id="6ca53-166">`AddTypeCommandBase` Třídy byl odebrán z `Add-Type` ke zlepšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-166">The `AddTypeCommandBase` class was removed from `Add-Type` to improve performance.</span></span> <span data-ttu-id="6ca53-167">Tato třída se používá jenom pomocí rutiny Add-Type a by neměla mít vliv na uživatele.</span><span class="sxs-lookup"><span data-stu-id="6ca53-167">This class is only used by the Add-Type cmdlet and should not impact users.</span></span>

### <a name="unify-cmdlets-with-parameter--encoding-to-be-of-type-systemtextencoding-5080httpsgithubcompowershellpowershellissues5080"></a><span data-ttu-id="6ca53-168">Sjednocení rutiny s parametrem `-Encoding` typu `System.Text.Encoding` [#5080](https://github.com/PowerShell/PowerShell/issues/5080)</span><span class="sxs-lookup"><span data-stu-id="6ca53-168">Unify cmdlets with parameter `-Encoding` to be of type `System.Text.Encoding` [#5080](https://github.com/PowerShell/PowerShell/issues/5080)</span></span>

<span data-ttu-id="6ca53-169">`-Encoding` Hodnotu `Byte` byla odebrána z rutiny zprostředkovatele systému souborů.</span><span class="sxs-lookup"><span data-stu-id="6ca53-169">The `-Encoding` value `Byte` has been removed from the filesystem provider cmdlets.</span></span> <span data-ttu-id="6ca53-170">Nový parametr `-AsByteStream`, se teď používá k určení, že datový proud bajtů se vyžaduje jako vstup nebo že je výstup datového proudu bajtů.</span><span class="sxs-lookup"><span data-stu-id="6ca53-170">A new parameter, `-AsByteStream`, is now used to specify that a byte stream is required as input or that the output is a stream of bytes.</span></span>

### <a name="add-better-error-message-for-empty-and-null--uformat-parameter-5055httpsgithubcompowershellpowershellissues5055"></a><span data-ttu-id="6ca53-171">Přidat lepší chybové zprávy pro prázdný a hodnota null `-UFormat` parametr [#5055](https://github.com/PowerShell/PowerShell/issues/5055)</span><span class="sxs-lookup"><span data-stu-id="6ca53-171">Add better error message for empty and null `-UFormat` parameter [#5055](https://github.com/PowerShell/PowerShell/issues/5055)</span></span>

<span data-ttu-id="6ca53-172">Dříve, když předávání formátu prázdný řetězec, který se `-UFormat`, by zobrazovat zbytečná zpráva.</span><span class="sxs-lookup"><span data-stu-id="6ca53-172">Previously, when passing an empty format string to `-UFormat`, an unhelpful error message would appear.</span></span> <span data-ttu-id="6ca53-173">Více popisná chybová byla přidána.</span><span class="sxs-lookup"><span data-stu-id="6ca53-173">A more descriptive error has been added.</span></span>

### <a name="clean-up-console-code-4995httpsgithubcompowershellpowershellissues4995"></a><span data-ttu-id="6ca53-174">Čištění kódu konzoly [#4995](https://github.com/PowerShell/PowerShell/issues/4995)</span><span class="sxs-lookup"><span data-stu-id="6ca53-174">Clean up console code [#4995](https://github.com/PowerShell/PowerShell/issues/4995)</span></span>

<span data-ttu-id="6ca53-175">Následující funkce byly odstraněny, protože nejsou podporovány v prostředí PowerShell Core a neexistují žádné plány. Chcete-li přidat podporu, protože existují kvůli starším verzím pro prostředí Windows PowerShell: `-psconsolefile` přepínače a kód, `-importsystemmodules` přepínače a kód a písma změny kódu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-175">The following features were removed as they are not supported in PowerShell Core, and there are no plans to add support as they exist for legacy reasons for Windows PowerShell: `-psconsolefile` switch and code, `-importsystemmodules` switch and code, and font changing code.</span></span>

### <a name="removed-runspaceconfiguration-support-4942httpsgithubcompowershellpowershellissues4942"></a><span data-ttu-id="6ca53-176">Odebrat `RunspaceConfiguration` podporují [#4942](https://github.com/PowerShell/PowerShell/issues/4942)</span><span class="sxs-lookup"><span data-stu-id="6ca53-176">Removed `RunspaceConfiguration` support [#4942](https://github.com/PowerShell/PowerShell/issues/4942)</span></span>

<span data-ttu-id="6ca53-177">Dříve při vytváření prostředí runspace Powershellu programově pomocí rozhraní API můžete použít starší [ `RunspaceConfiguration` ] [ runspaceconfig] nebo novější [ `InitialSessionState` ] [ iss].</span><span class="sxs-lookup"><span data-stu-id="6ca53-177">Previously, when creating a PowerShell runspace programmatically using the API you could use the legacy [`RunspaceConfiguration`][runspaceconfig] or the newer [`InitialSessionState`][iss].</span></span> <span data-ttu-id="6ca53-178">Tato změna odebrala podpora pro `RunspaceConfiguration` a podporuje pouze `InitialSessionState`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-178">This change removed support for `RunspaceConfiguration` and only supports `InitialSessionState`.</span></span>

[runspaceconfig]: https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.runspaceconfiguration
[iss]: https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.initialsessionstate

### <a name="commandinvocationintrinsicsinvokescript-bind-arguments-to-input-instead-of-args-4923httpsgithubcompowershellpowershellissues4923"></a><span data-ttu-id="6ca53-179">`CommandInvocationIntrinsics.InvokeScript` Vytvoření vazby argumenty, které mají `$input` místo `$args` [#4923](https://github.com/PowerShell/PowerShell/issues/4923)</span><span class="sxs-lookup"><span data-stu-id="6ca53-179">`CommandInvocationIntrinsics.InvokeScript` bind arguments to `$input` instead of `$args` [#4923](https://github.com/PowerShell/PowerShell/issues/4923)</span></span>

<span data-ttu-id="6ca53-180">Nesprávná pozice parametru výsledkem args předané jako vstup místo jako argumenty.</span><span class="sxs-lookup"><span data-stu-id="6ca53-180">An incorrect position of a parameter resulted in the args passed as input instead of as args.</span></span>

### <a name="remove-unsupported--showwindow-switch-from-get-help-4903httpsgithubcompowershellpowershellissues4903"></a><span data-ttu-id="6ca53-181">Odeberte nepodporované `-showwindow` přejít z `Get-Help` [#4903](https://github.com/PowerShell/PowerShell/issues/4903)</span><span class="sxs-lookup"><span data-stu-id="6ca53-181">Remove unsupported `-showwindow` switch from `Get-Help` [#4903](https://github.com/PowerShell/PowerShell/issues/4903)</span></span>

<span data-ttu-id="6ca53-182">`-showwindow` spoléhá na WPF, což není podporováno u CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="6ca53-182">`-showwindow` relies on WPF, which is not supported on CoreCLR.</span></span>

### <a name="allow--to-be-used-in-registry-path-for-remove-item-4866httpsgithubcompowershellpowershellissues4866"></a><span data-ttu-id="6ca53-183">Povolit \* pro použití v cestě registru pro `Remove-Item` [#4866](https://github.com/PowerShell/PowerShell/issues/4866)</span><span class="sxs-lookup"><span data-stu-id="6ca53-183">Allow \* to be used in registry path for `Remove-Item` [#4866](https://github.com/PowerShell/PowerShell/issues/4866)</span></span>

<span data-ttu-id="6ca53-184">Dříve `-LiteralPath` daný zástupný znak by ji považovat za stejné `-Path` a pokud zástupný znak nenajde žádné soubory, bude tiše ukončíte.</span><span class="sxs-lookup"><span data-stu-id="6ca53-184">Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard found no files, it would silently exit.</span></span> <span data-ttu-id="6ca53-185">Správné chování, která by měla být `-LiteralPath` je literál, takže pokud soubor neexistuje, by mělo chyby.</span><span class="sxs-lookup"><span data-stu-id="6ca53-185">Correct behavior should be that `-LiteralPath` is literal so if the file doesn't exist, it should error.</span></span> <span data-ttu-id="6ca53-186">Změna se zachází zástupných znaků použít s `-Literal` jako literál.</span><span class="sxs-lookup"><span data-stu-id="6ca53-186">Change is to treat wildcards used with `-Literal` as literal.</span></span>

### <a name="fix-set-service-failing-test-4802httpsgithubcompowershellpowershellissues4802"></a><span data-ttu-id="6ca53-187">Oprava `Set-Service` selhání testu [#4802](https://github.com/PowerShell/PowerShell/issues/4802)</span><span class="sxs-lookup"><span data-stu-id="6ca53-187">Fix `Set-Service` failing test [#4802](https://github.com/PowerShell/PowerShell/issues/4802)</span></span>

<span data-ttu-id="6ca53-188">Dříve Pokud `New-Service -StartupType foo` byl použit `foo` byla ignorována a služba byla vytvořena s nějakým typem výchozí spuštění.</span><span class="sxs-lookup"><span data-stu-id="6ca53-188">Previously, if `New-Service -StartupType foo` was used, `foo` was ignored and the service was created with some default startup type.</span></span> <span data-ttu-id="6ca53-189">Tato změna je explicitně vyvolání k chybě typu neplatná spouštěcí.</span><span class="sxs-lookup"><span data-stu-id="6ca53-189">This change is to explicitly throw an error for an invalid startup type.</span></span>

### <a name="rename-isosx-to-ismacos-4700httpsgithubcompowershellpowershellissues4700"></a><span data-ttu-id="6ca53-190">Přejmenovat `$IsOSX` k `$IsMacOS` [#4700](https://github.com/PowerShell/PowerShell/issues/4700)</span><span class="sxs-lookup"><span data-stu-id="6ca53-190">Rename `$IsOSX` to `$IsMacOS` [#4700](https://github.com/PowerShell/PowerShell/issues/4700)</span></span>

<span data-ttu-id="6ca53-191">Pojmenování v prostředí PowerShell by bylo v souladu s naší pojmenování a v souladu s použití společnosti Apple MacOS místo OSX.</span><span class="sxs-lookup"><span data-stu-id="6ca53-191">The naming in PowerShell should be consistent with our naming and conform to Apple's use of macOS instead of OSX.</span></span> <span data-ttu-id="6ca53-192">Ale pro lepší čitelnost a důsledně se můžeme zůstává s Pascal velká a malá písmena.</span><span class="sxs-lookup"><span data-stu-id="6ca53-192">However, for readability and consistently we are staying with Pascal casing.</span></span>

### <a name="make-error-message-consistent-when-invalid-script-is-passed-to--file-better-error-when-passed-ambiguous-argument-4573httpsgithubcompowershellpowershellissues4573"></a><span data-ttu-id="6ca53-193">Ujistěte se, chybová zpráva konzistentní při předání neplatný skript – soubor, lepší chyby při předání argumentu nejednoznačný [#4573](https://github.com/PowerShell/PowerShell/issues/4573)</span><span class="sxs-lookup"><span data-stu-id="6ca53-193">Make error message consistent when invalid script is passed to -File, better error when passed ambiguous argument [#4573](https://github.com/PowerShell/PowerShell/issues/4573)</span></span>

<span data-ttu-id="6ca53-194">Změnit ukončovací kód z `pwsh.exe` souladu s konvencemi systému Unix</span><span class="sxs-lookup"><span data-stu-id="6ca53-194">Change the exit codes of `pwsh.exe` to align with Unix conventions</span></span>

### <a name="removal-of-localaccount-and-cmdlets-from--diagnostics-modules-4302httpsgithubcompowershellpowershellissues4302-4303httpsgithubcompowershellpowershellissues4303"></a><span data-ttu-id="6ca53-195">Odebrání `LocalAccount` a rutiny z `Diagnostics` moduly.</span><span class="sxs-lookup"><span data-stu-id="6ca53-195">Removal of `LocalAccount` and cmdlets from  `Diagnostics` modules.</span></span> <span data-ttu-id="6ca53-196">[#4302](https://github.com/PowerShell/PowerShell/issues/4302) [#4303](https://github.com/PowerShell/PowerShell/issues/4303)</span><span class="sxs-lookup"><span data-stu-id="6ca53-196">[#4302](https://github.com/PowerShell/PowerShell/issues/4302) [#4303](https://github.com/PowerShell/PowerShell/issues/4303)</span></span>

<span data-ttu-id="6ca53-197">Z důvodu nepodporované rozhraní API `LocalAccounts` modulu a `Counter` rutiny v `Diagnostics` modul byly odebrány, dokud nebude nalezen lepší řešení.</span><span class="sxs-lookup"><span data-stu-id="6ca53-197">Due to unsupported APIs, the `LocalAccounts` module and the `Counter` cmdlets in the `Diagnostics` module were removed until a better solution is found.</span></span>

### <a name="executing-powershell-script-with-bool-parameter-does-not-work-4036httpsgithubcompowershellpowershellissues4036"></a><span data-ttu-id="6ca53-198">Spuštění powershellového skriptu s parametrem bool nefunguje [#4036](https://github.com/PowerShell/PowerShell/issues/4036)</span><span class="sxs-lookup"><span data-stu-id="6ca53-198">Executing powershell script with bool parameter does not work [#4036](https://github.com/PowerShell/PowerShell/issues/4036)</span></span>

<span data-ttu-id="6ca53-199">Dříve, pomocí powershell.exe (nyní `pwsh.exe`) Chcete-li spustit skript prostředí PowerShell pomocí `-File` k dispozici žádný způsob, jak předat $true nebo $false jako hodnoty parametrů.</span><span class="sxs-lookup"><span data-stu-id="6ca53-199">Previously, using powershell.exe (now `pwsh.exe`) to execute a PowerShell script using `-File` provided no way to pass $true/$false as parameter values.</span></span> <span data-ttu-id="6ca53-200">Podpora pro $true nebo $false jako analyzované hodnoty pro parametry byl přidán.</span><span class="sxs-lookup"><span data-stu-id="6ca53-200">Support for $true/$false as parsed values to parameters was added.</span></span> <span data-ttu-id="6ca53-201">Přepínač hodnoty jsou také podporovány jako aktuálně zdokumentovaných syntaxe nebude fungovat.</span><span class="sxs-lookup"><span data-stu-id="6ca53-201">Switch values are also supported as currently documented syntax doesn't work.</span></span>

### <a name="remove-clrversion-property-from-psversiontable-4027httpsgithubcompowershellpowershellissues4027"></a><span data-ttu-id="6ca53-202">Odebrat `ClrVersion` vlastnost z `$PSVersionTable` [#4027](https://github.com/PowerShell/PowerShell/issues/4027)</span><span class="sxs-lookup"><span data-stu-id="6ca53-202">Remove `ClrVersion` property from `$PSVersionTable` [#4027](https://github.com/PowerShell/PowerShell/issues/4027)</span></span>

<span data-ttu-id="6ca53-203">`ClrVersion` Vlastnost `$PSVersionTable` není užitečný v případě CoreCLR, koncoví uživatelé neměli byste používat tuto hodnotu k určování kompatibility.</span><span class="sxs-lookup"><span data-stu-id="6ca53-203">The `ClrVersion` property of `$PSVersionTable` is not useful with CoreCLR, end users should not be using that value to determine compatibility.</span></span>

### <a name="change-positional-parameter-for-powershellexe-from--command-to--file-4019httpsgithubcompowershellpowershellissues4019"></a><span data-ttu-id="6ca53-204">Změnit pozičních parametrů více dopředu pro `powershell.exe` z `-Command` k `-File` [#4019](https://github.com/PowerShell/PowerShell/issues/4019)</span><span class="sxs-lookup"><span data-stu-id="6ca53-204">Change positional parameter for `powershell.exe` from `-Command` to `-File` [#4019](https://github.com/PowerShell/PowerShell/issues/4019)</span></span>

<span data-ttu-id="6ca53-205">Povolte používání shebang powershellu na platformách než Windows.</span><span class="sxs-lookup"><span data-stu-id="6ca53-205">Enable shebang use of PowerShell on non-Windows platforms.</span></span> <span data-ttu-id="6ca53-206">To znamená, že v systémech Unix na základě provedete skript spustitelný soubor, který by měl vyvolat Powershellu automaticky místo explicitně vyvolání `pwsh`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-206">This means on Unix based systems, you can make a script executable that would invoke PowerShell automatically rather than explicitly invoking `pwsh`.</span></span> <span data-ttu-id="6ca53-207">Zároveň to znamená, že můžete teď provádět věci, jako je `powershell foo.ps1` nebo `powershell fooScript` bez zadání `-File`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-207">This also means that you can now do things like `powershell foo.ps1` or `powershell fooScript` without specifying `-File`.</span></span> <span data-ttu-id="6ca53-208">Však tuto změnu teď potřeba explicitně zadat `-c` nebo `-Command` při pokusu provést třeba `powershell.exe Get-Command`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-208">However, this change now requires that you explicitly specify `-c` or `-Command` when trying to do things like `powershell.exe Get-Command`.</span></span>

### <a name="implement-unicode-escape-parsing-3958httpsgithubcompowershellpowershellissues3958"></a><span data-ttu-id="6ca53-209">Implementace analýzy řídicí Unicode [#3958](https://github.com/PowerShell/PowerShell/issues/3958)</span><span class="sxs-lookup"><span data-stu-id="6ca53-209">Implement Unicode escape parsing [#3958](https://github.com/PowerShell/PowerShell/issues/3958)</span></span>

<span data-ttu-id="6ca53-210">`` `u#### `` nebo `` `u{####} `` je převést na odpovídající znak Unicode.</span><span class="sxs-lookup"><span data-stu-id="6ca53-210">`` `u#### `` or `` `u{####} `` is converted to the corresponding Unicode character.</span></span> <span data-ttu-id="6ca53-211">Do výstupního literál `` `u ``, řídicí prvními: ``` ``u ```.</span><span class="sxs-lookup"><span data-stu-id="6ca53-211">To output a literal `` `u ``, escape the backtick: ``` ``u ```.</span></span>

### <a name="change-new-modulemanifest-encoding-to-utf8nobom-on-non-windows-platforms-3940httpsgithubcompowershellpowershellissues3940"></a><span data-ttu-id="6ca53-212">Změna `New-ModuleManifest` kódování `UTF8NoBOM` na platformách než Windows [#3940](https://github.com/PowerShell/PowerShell/issues/3940)</span><span class="sxs-lookup"><span data-stu-id="6ca53-212">Change `New-ModuleManifest` encoding to `UTF8NoBOM` on non-Windows platforms [#3940](https://github.com/PowerShell/PowerShell/issues/3940)</span></span>

<span data-ttu-id="6ca53-213">Dříve `New-ModuleManifest` vytvoří psd1 manifesty v kódování UTF-16 s BOM vytváření problém pro Linux nástroje.</span><span class="sxs-lookup"><span data-stu-id="6ca53-213">Previously, `New-ModuleManifest` creates psd1 manifests in UTF-16 with BOM, creating a problem for Linux tools.</span></span> <span data-ttu-id="6ca53-214">Tato změna zásadní změny kódování `New-ModuleManifest` být UTF (BOM) na platformách než Windows.</span><span class="sxs-lookup"><span data-stu-id="6ca53-214">This breaking change changes the encoding of `New-ModuleManifest` to be UTF (no BOM) in non-Windows platforms.</span></span>

### <a name="prevent-get-childitem-from-recursing-into-symlinks-1875-3780httpsgithubcompowershellpowershellissues3780"></a><span data-ttu-id="6ca53-215">Zabránit `Get-ChildItem` z recursing do symbolických odkazů (#1875).</span><span class="sxs-lookup"><span data-stu-id="6ca53-215">Prevent `Get-ChildItem` from recursing into symlinks (#1875).</span></span> [<span data-ttu-id="6ca53-216">#3780</span><span class="sxs-lookup"><span data-stu-id="6ca53-216">#3780</span></span>](https://github.com/PowerShell/PowerShell/issues/3780)

<span data-ttu-id="6ca53-217">Tato změna přináší `Get-ChildItem` další podle Unix `ls -r` a Windows `dir /s` nativní příkazy.</span><span class="sxs-lookup"><span data-stu-id="6ca53-217">This change brings `Get-ChildItem` more in line with the Unix `ls -r` and the Windows `dir /s` native commands.</span></span> <span data-ttu-id="6ca53-218">Stejně jako příkazy uvedené rutina zobrazí symbolické odkazy k adresářům během rekurze nalezen, ale není do nich recurse.</span><span class="sxs-lookup"><span data-stu-id="6ca53-218">Like the mentioned commands, the cmdlet displays symbolic links to directories found during recursion, but does not recurse into them.</span></span>

### <a name="fix-get-content--delimiter-to-not-include-the-delimiter-in-the-returned-lines-3706httpsgithubcompowershellpowershellissues3706"></a><span data-ttu-id="6ca53-219">Oprava `Get-Content -Delimiter` tak, aby nezahrnovala oddělovač ve vrácených řádcích [#3706](https://github.com/PowerShell/PowerShell/issues/3706)</span><span class="sxs-lookup"><span data-stu-id="6ca53-219">Fix `Get-Content -Delimiter` to not include the delimiter in the returned lines [#3706](https://github.com/PowerShell/PowerShell/issues/3706)</span></span>

<span data-ttu-id="6ca53-220">Dříve, výstup při používání `Get-Content -Delimiter` byl nekonzistentní a nepohodlná, protože ta vyžaduje další zpracování dat k odebrání oddělovač.</span><span class="sxs-lookup"><span data-stu-id="6ca53-220">Previously, the output while using `Get-Content -Delimiter` was inconsistent and inconvenient as it required further processing of the data to remove the delimiter.</span></span> <span data-ttu-id="6ca53-221">Tato změna odebere oddělovač ve vrácených řádcích.</span><span class="sxs-lookup"><span data-stu-id="6ca53-221">This change removes the delimiter in returned lines.</span></span>

### <a name="implement-format-hex-in-c-3320httpsgithubcompowershellpowershellissues3320"></a><span data-ttu-id="6ca53-222">Implementace formát Hex C# [#3320](https://github.com/PowerShell/PowerShell/issues/3320)</span><span class="sxs-lookup"><span data-stu-id="6ca53-222">Implement Format-Hex in C# [#3320](https://github.com/PowerShell/PowerShell/issues/3320)</span></span>

<span data-ttu-id="6ca53-223">`-Raw` Parametr je nyní "no-op" (v tom to nemá žádný účinek).</span><span class="sxs-lookup"><span data-stu-id="6ca53-223">The `-Raw` parameter is now a "no-op" (in that it does nothing).</span></span> <span data-ttu-id="6ca53-224">Výhledově bude veškerý výstup se zobrazí s true reprezentace čísla, která zahrnuje všechny bajty pro daný typ (co `-Raw` parametr dělal formálně před touto změnou).</span><span class="sxs-lookup"><span data-stu-id="6ca53-224">Going forward all of the output will be displayed with a true representation of numbers that includes all of the bytes for its type (what the `-Raw` parameter was formally doing prior to this change).</span></span>

### <a name="powershell-as-a-default-shell-doesnt-work-with-script-command-3319httpsgithubcompowershellpowershellissues3319"></a><span data-ttu-id="6ca53-225">Prostředí PowerShell jako výchozí prostředí nefunguje při využití příkaz skriptu [#3319](https://github.com/PowerShell/PowerShell/issues/3319)</span><span class="sxs-lookup"><span data-stu-id="6ca53-225">PowerShell as a default shell doesn't work with script command [#3319](https://github.com/PowerShell/PowerShell/issues/3319)</span></span>

<span data-ttu-id="6ca53-226">V systému Unix, je konvence pro prostředí tak, aby přijímal `-i` pro toto chování očekávalo interaktivní prostředí a celou řadu nástrojů (`script` například a při nastavení prostředí PowerShell jako výchozí prostředí) a zavolá prostředí s `-i` přepnout.</span><span class="sxs-lookup"><span data-stu-id="6ca53-226">On Unix, it is a convention for shells to accept `-i` for an interactive shell and many tools expect this behavior (`script` for example, and when setting PowerShell as the default shell) and calls the shell with the `-i` switch.</span></span> <span data-ttu-id="6ca53-227">Tato změna je zásadní v dané `-i` dříve může sloužit jako krátký ručně tak, aby odpovídaly `-inputformat`, které je teď potřeba `-in`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-227">This change is breaking in that `-i` previously could be used as short hand to match `-inputformat`, which now needs to be `-in`.</span></span>

### <a name="typo-fix-in-get-computerinfo-property-name-3167httpsgithubcompowershellpowershellissues3167"></a><span data-ttu-id="6ca53-228">Oprava překlep v názvu vlastnosti Get-ComputerInfo [#3167](https://github.com/PowerShell/PowerShell/issues/3167)</span><span class="sxs-lookup"><span data-stu-id="6ca53-228">Typo fix in Get-ComputerInfo property name [#3167](https://github.com/PowerShell/PowerShell/issues/3167)</span></span>

<span data-ttu-id="6ca53-229">`BiosSerialNumber` bylo zadáno chybně jako `BiosSeralNumber` a byl změněn na správně.</span><span class="sxs-lookup"><span data-stu-id="6ca53-229">`BiosSerialNumber` was misspelled as `BiosSeralNumber` and has been changed to the correct spelling.</span></span>

### <a name="add-get-stringhash-and-get-filehash-cmdlets-3024httpsgithubcompowershellpowershellissues3024"></a><span data-ttu-id="6ca53-230">Přidat `Get-StringHash` a `Get-FileHash` rutiny [#3024](https://github.com/PowerShell/PowerShell/issues/3024)</span><span class="sxs-lookup"><span data-stu-id="6ca53-230">Add `Get-StringHash` and `Get-FileHash` cmdlets [#3024](https://github.com/PowerShell/PowerShell/issues/3024)</span></span>

<span data-ttu-id="6ca53-231">Tato změna je, že některé hashovacích algoritmů nepodporuje CoreFX, proto už nejsou k dispozici:</span><span class="sxs-lookup"><span data-stu-id="6ca53-231">This change is that some hash algorithms are not supported by CoreFX, therefore they are no longer available:</span></span>

- `MACTripleDES`
- `RIPEMD160`

### <a name="add-validation-on-get--cmdlets-where-passing-null-returns-all-objects-instead-of-error-2672httpsgithubcompowershellpowershellissues2672"></a><span data-ttu-id="6ca53-232">Přidání ověřování na `Get-*` rutiny, kde předávání $null vrátí všechny objekty místo chyby [#2672](https://github.com/PowerShell/PowerShell/issues/2672)</span><span class="sxs-lookup"><span data-stu-id="6ca53-232">Add validation on `Get-*` cmdlets where passing $null returns all objects instead of error [#2672](https://github.com/PowerShell/PowerShell/issues/2672)</span></span>

<span data-ttu-id="6ca53-233">Předání `$null` na některý z následujících nyní vyvolá chybu:</span><span class="sxs-lookup"><span data-stu-id="6ca53-233">Passing `$null` to any of the following now throws an error:</span></span>

- `Get-Credential -UserName`
- `Get-Event -SourceIdentifier`
- `Get-EventSubscriber -SourceIdentifier`
- `Get-Help -Name`
- `Get-PSBreakpoint -Script`
- `Get-PSProvider -PSProvider`
- `Get-PSSessionConfiguration -Name`
- `Get-PSSnapin -Name`
- `Get-Runspace -Name`
- `Get-RunspaceDebug -RunspaceName`
- `Get-Service -Name`
- `Get-TraceSource -Name`
- `Get-Variable -Name`
- `Get-WmiObject -Class`
- `Get-WmiObject -Property`

### <a name="add-support-w3c-extended-log-file-format-in-import-csv-2482httpsgithubcompowershellpowershellissues2482"></a><span data-ttu-id="6ca53-234">Přidání podpory W3C rozšířený formát souborů protokolu v `Import-Csv` [#2482](https://github.com/PowerShell/PowerShell/issues/2482)</span><span class="sxs-lookup"><span data-stu-id="6ca53-234">Add support W3C Extended Log File Format in `Import-Csv` [#2482](https://github.com/PowerShell/PowerShell/issues/2482)</span></span>

<span data-ttu-id="6ca53-235">Dříve `Import-Csv` rutiny nelze použít k přímému importu souborů protokolu v rozšířeném formátu protokolu W3C a provádět další akce by bylo zapotřebí.</span><span class="sxs-lookup"><span data-stu-id="6ca53-235">Previously, the `Import-Csv` cmdlet cannot be used to directly import the log files in W3C extended log format and additional action would be required.</span></span> <span data-ttu-id="6ca53-236">Díky této změně se podporuje rozšířený formát protokolu W3C.</span><span class="sxs-lookup"><span data-stu-id="6ca53-236">With this change, W3C extended log format is supported.</span></span>

### <a name="parameter-binding-problem-with-valuefromremainingarguments-in-ps-functions-2035httpsgithubcompowershellpowershellissues2035"></a><span data-ttu-id="6ca53-237">Parametr vazby problém s `ValueFromRemainingArguments` ve funkcích PS [#2035](https://github.com/PowerShell/PowerShell/issues/2035)</span><span class="sxs-lookup"><span data-stu-id="6ca53-237">Parameter binding problem with `ValueFromRemainingArguments` in PS functions [#2035](https://github.com/PowerShell/PowerShell/issues/2035)</span></span>

<span data-ttu-id="6ca53-238">`ValueFromRemainingArguments` nyní vrátí hodnoty jako pole namísto jediného hodnotu, která sama je pole.</span><span class="sxs-lookup"><span data-stu-id="6ca53-238">`ValueFromRemainingArguments` now returns the values as an array instead of a single value which itself is an array.</span></span>

### <a name="buildversion-is-removed-from-psversiontable-1415httpsgithubcompowershellpowershellissues1415"></a><span data-ttu-id="6ca53-239">`BuildVersion` Odebereme z `$PSVersionTable` [#1415](https://github.com/PowerShell/PowerShell/issues/1415)</span><span class="sxs-lookup"><span data-stu-id="6ca53-239">`BuildVersion` is removed from `$PSVersionTable` [#1415](https://github.com/PowerShell/PowerShell/issues/1415)</span></span>

<span data-ttu-id="6ca53-240">Odeberte `BuildVersion` vlastnost z `$PSVersionTable`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-240">Remove the `BuildVersion` property from `$PSVersionTable`.</span></span> <span data-ttu-id="6ca53-241">Tato vlastnost se vázalo na verzi Windows sestavení.</span><span class="sxs-lookup"><span data-stu-id="6ca53-241">This property was tied to the Windows build version.</span></span> <span data-ttu-id="6ca53-242">Namísto toho doporučujeme použít `GitCommitId` sestavení přesnou verzi prostředí PowerShell Core.</span><span class="sxs-lookup"><span data-stu-id="6ca53-242">Instead, we recommend that you use `GitCommitId` to retrieve the exact build version of PowerShell Core.</span></span>

### <a name="changes-to-web-cmdlets"></a><span data-ttu-id="6ca53-243">Změny v rutinách webové</span><span class="sxs-lookup"><span data-stu-id="6ca53-243">Changes to Web Cmdlets</span></span>

<span data-ttu-id="6ca53-244">Základní rozhraní .NET API rutin Web byl změněn na `System.Net.Http.HttpClient`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-244">The underlying .NET API of the Web Cmdlets has been changed to `System.Net.Http.HttpClient`.</span></span> <span data-ttu-id="6ca53-245">Tato změna má spoustu výhod.</span><span class="sxs-lookup"><span data-stu-id="6ca53-245">This change provides many benefits.</span></span> <span data-ttu-id="6ca53-246">Ale tato změna spolu s chybějící interoperability s aplikací Internet Explorer vyústila v několika rozbíjející změny v rámci `Invoke-WebRequest` a `Invoke-RestMethod`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-246">However, this change along with a lack of interoperability with Internet Explorer have resulted in several breaking changes within `Invoke-WebRequest` and `Invoke-RestMethod`.</span></span>

- <span data-ttu-id="6ca53-247">`Invoke-WebRequest` Teď podporuje základní HTML Parsování pouze.</span><span class="sxs-lookup"><span data-stu-id="6ca53-247">`Invoke-WebRequest` now supports basic HTML Parsing only.</span></span> <span data-ttu-id="6ca53-248">`Invoke-WebRequest` vždy vrátí hodnotu `BasicHtmlWebResponseObject` objektu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-248">`Invoke-WebRequest` always returns a `BasicHtmlWebResponseObject` object.</span></span> <span data-ttu-id="6ca53-249">`ParsedHtml` a `Forms` byly odebrány vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="6ca53-249">The `ParsedHtml` and `Forms` properties have been removed.</span></span>
- <span data-ttu-id="6ca53-250">`BasicHtmlWebResponseObject.Headers` hodnoty jsou nyní `String[]` místo `String`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-250">`BasicHtmlWebResponseObject.Headers` values are now `String[]` instead of `String`.</span></span>
- <span data-ttu-id="6ca53-251">`BasicHtmlWebResponseObject.BaseResponse` je teď `System.Net.Http.HttpResponseMessage` objektu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-251">`BasicHtmlWebResponseObject.BaseResponse` is now a `System.Net.Http.HttpResponseMessage` object.</span></span>
- <span data-ttu-id="6ca53-252">`Response` Vlastnost na Web rutiny výjimky je nyní `System.Net.Http.HttpResponseMessage` objektu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-252">The `Response` property on Web Cmdlet exceptions is now a `System.Net.Http.HttpResponseMessage` object.</span></span>
- <span data-ttu-id="6ca53-253">Analýza striktní RFC záhlaví je teď výchozí nastavení pro `-Headers` a `-UserAgent` parametru.</span><span class="sxs-lookup"><span data-stu-id="6ca53-253">Strict RFC header parsing is now default for the `-Headers` and `-UserAgent` parameter.</span></span> <span data-ttu-id="6ca53-254">To lze obejít s `-SkipHeaderValidation`.</span><span class="sxs-lookup"><span data-stu-id="6ca53-254">This can be bypassed with `-SkipHeaderValidation`.</span></span>
- <span data-ttu-id="6ca53-255">`file://` a `ftp://` schémata identifikátoru URI již nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="6ca53-255">`file://` and `ftp://` URI schemes are no longer supported.</span></span>
- <span data-ttu-id="6ca53-256">`System.Net.ServicePointManager` nastavení omezení se už nebude dodržena.</span><span class="sxs-lookup"><span data-stu-id="6ca53-256">`System.Net.ServicePointManager` settings are no longer honored.</span></span>
- <span data-ttu-id="6ca53-257">Není aktuálně bez ověřování na základě certifikátů k dispozici v systému macOS.</span><span class="sxs-lookup"><span data-stu-id="6ca53-257">There is currently no certificate based authentication available on macOS.</span></span>
- <span data-ttu-id="6ca53-258">Použití `-Credential` přes `http://` URI způsobí chybu.</span><span class="sxs-lookup"><span data-stu-id="6ca53-258">Use of `-Credential` over an `http://` URI will result in an error.</span></span> <span data-ttu-id="6ca53-259">Použití `https://` identifikátor URI nebo zadat `-AllowUnencryptedAuthentication` parametr potlačit chyby.</span><span class="sxs-lookup"><span data-stu-id="6ca53-259">Use an `https://` URI or supply the `-AllowUnencryptedAuthentication` parameter to suppress the error.</span></span>
- <span data-ttu-id="6ca53-260">`-MaximumRedirection` nyní vytvoří dojde k ukončující chybě při pokusy o přesměrování překračuje zadaný limit místo vrácení výsledků z poslední přesměrování.</span><span class="sxs-lookup"><span data-stu-id="6ca53-260">`-MaximumRedirection` now produces a terminating error when redirection attempts exceed the provided limit instead of returning the results of the last redirection.</span></span>
